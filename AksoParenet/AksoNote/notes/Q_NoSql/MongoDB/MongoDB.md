									**MongoDB**

MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。

MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

# 1. NoSQL 简介

NoSQL(NoSQL = Not Only SQL )，意即"不仅仅是SQL"。

在现代的计算系统上每天网络上都会产生庞大的数据量。

这些数据有很大一部分是由关系数据库管理系统（RDBMS）来处理。 1970年 E.F.Codd's提出的关系模型的论文 "A relational model of data for large shared data banks"，这使得数据建模和应用程序编程更加简单。

通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。

NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。

**关系型数据库遵循ACID规则**

事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：

**1、A (Atomicity) 原子性**

原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。

**2、C (Consistency) 一致性**

一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。

**3、I (Isolation) 独立性**

所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。

**4、D (Durability) 持久性**

持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。

**分布式系统**

分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。

分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。

因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。

分布式系统可以应用在不同的平台上如：Pc、工作站、局域网和广域网上等。

**分布式计算的优点**

**可靠性（容错） ：**

分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。

**可扩展性：**

在分布式计算系统可以根据需要增加更多的机器。

**资源共享：**

共享数据是必不可少的应用，如银行，预订系统。

**灵活性：**

由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。

**更快的速度：**

分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。

**开放系统：**

由于它是开放的系统，本地或者远程都可以访问到该服务。

**更高的性能：**

相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。

**分布式计算的缺点**

**故障排除：**

故障排除和诊断问题。

**软件：**

更少的软件支持是分布式计算系统的主要缺点。

**网络：**

网络基础设施的问题，包括：传输问题，高负载，信息丢失等。

**安全性：**

开放系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。

**什么是NoSQL?**

NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。

NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。

**为什么使用NoSQL ?**

今天我们可以通过第三方平台（如：Google, Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL 数据库的发展却能很好的处理这些大的数据。

**RDBMS vs NoSQL**

**RDBMS** 
\- 高度组织化结构化数据 
\- 结构化查询语言（SQL） (SQL) 
\- 数据和关系都存储在单独的表中。 
\- 数据操纵语言，数据定义语言 
\- 严格的一致性
\- 基础事务

**NoSQL** 
\- 代表着不仅仅是SQL
\- 没有声明性查询语言
\- 没有预定义的模式
-键 - 值对存储，列存储，文档存储，图形数据库
\- 最终一致性，而非ACID属性
\- 非结构化和不可预知的数据
\- CAP定理 
\- 高性能，高可用性和可伸缩性

# 2. MongoDB 的增删改查

## 2.1、集合

创建集合：use 集合名

删除集合：db.集合名.drop()

删除当前所有集合：db.dropDatabase() --慎用

创建固定集合：db.createCollection("集合名", { capped : true, autoIndexId : true, size : 集合空间大小, max : 文档最大个数} )

注：新建集合是无法查看到的，但它存在，需要向它新增数据然后才能够查看到

在MongoDB中不需要新建集合，当你新增数据时，他会为你自动创建集合

 

查看所有集合所占内存：show dbs

查看已有集合：show collections

## 2.2、数据

查询：db.getCollection('要查询的集合名').find({"要查询的列名","要查询的值"})

新增：db.集合名.insert({title: 'MongoDB 教程', description: 'MongoDB 是一个 Nosql 数据库', by: '菜鸟教程', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 })

删除：db.getCollection('要删除的集合名').remove({"要删除的列名":"要删除的值"})

修改：db.集合名.update（{'要修改的列名'：'要修改的原数据的值'}，{$ set：{'要修改的列名'：'要修改成的数据的值'}}）

 

注：定义到sql语句要操作的集合的方法有两种，

（1）、db.getCollection('集合名').要进行的操作(insert、find、remove、update)(条件书写格式一致)

（2）、db.集合名.要进行的操作(insert、find、remove、update)(条件书写格式一致)

集合列名不可为中文，可不用引号包括

新增数值型数据，将要新增的字段值不要使用引号包括，他会自动给数值赋Double

 

数据操作：
show collections；#查看集合
创建集合、插入：
db.createCcollection();#创建集合
db.student.insert({"name":"张三","age":"22","sex":"男","class":"计算机2班"});#如果数据库中不存在集合，就创建并插入这些数据
db.student.insert({"name":"李四","age":"22","sex":"女","phone":"18513081650","class":"计算机1班"});#里面的key-value不用保持一致
db.student.insert([{"name":"王五","age":"22","sex":"男","class":"计算机2班"},{"name":"赵六","age":"22","sex":"女","phone":"18513081650","class":"计算机1班"}]);#同时插入多条数据

更新：
db.student.update({"name":"张三"},{"name":"张三丰"});#如果有多条语句，只修改第一条，会覆盖原有数据
db.student.update({"22":"女"},{"name":"张三丰"});
db.student.update({"name":"张三"},{$set:{"name":"张无忌"}});#只想改某个key的value使用set
db.student.update({"name":"王五"},{$set:{"name":"张无忌"}},{multi:true});#把所有的记录都改了

查询：
db.student.find();#查询全部
db.student.find({"name":"李四"});#查询指定记录，返回这一行结果
db.student.find({"name":"张无忌","age":"28"});#and操作
db.student.find({$or:[{"name":"张无忌"},{"name":"李四"}]});#or操作
db.student.find().pretty();#格式化显示
db.student.find().count();#获取结果的行数
db.student.find().sort({"age":-1});#按照sort里面key的值排序，1为正序，-1为倒序

删除：
db.student.remove();#删除所有数据
db.student.remove({"22":"女"});#按照条件删除
db.student.remove({"name":"张无忌"},2);#删除几条



## 2.3、条件判断运算符(>、<、>=、<=、< 列名<、!=、==)

> : db.集合名.find({"进行判断的列名" : {$gt : 100}})

< : db.集合名.find({进行判断的列名 : {$lt : 150}})

>= : db.集合名.find({进行判断的列名 : {$gte : 100}})

<= : db.集合名.find({进行判断的列名 : {$lte : 150}})

<列名< : db.集合名.find({进行判断的列名 : {$lt :200, $gt : 100}})

注：

$gt -------- greater than >

$gte --------- gt equal >=

$lt -------- less than <

$lte --------- lt equal <=

$ne ----------- not equal !=

$eq -------- equal ==

 

## 2.4、排序

升序 ：db.集合名.find().sort({列名:1})

降序 ：db.集合名.find().sort({列名:-1})

根据升序降序获取指定列的值：db.col.find({},{"所要查询的列名":1,_id:0}).sort({"进行排序的列名":-1})

# 3. 聚合操作

MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。

**aggregate**() 方法

MongoDB中聚合的方法使用aggregate()。

**语法**

aggregate() 方法的基本语法格式如下所示：

```
>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
```

下表展示了一些聚合的表达式:

| 表达式    | 描述                                           | 实例                                                         |
| :-------- | :--------------------------------------------- | :----------------------------------------------------------- |
| $sum      | 计算总和。                                     | db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}]) |
| $avg      | 计算平均值                                     | db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}]) |
| $min      | 获取集合中所有文档对应值得最小值。             | db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}]) |
| $max      | 获取集合中所有文档对应值得最大值。             | db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}]) |
| $push     | 在结果文档中插入值到一个数组中。               | db.mycol.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}]) |
| $addToSet | 在结果文档中插入值到一个数组中，但不创建副本。 | db.mycol.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}]) |
| $first    | 根据资源文档的排序获取第一个文档数据。         | db.mycol.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}]) |
| $last     | 根据资源文档的排序获取最后一个文档数据         | db.mycol.aggregate([{$group : {_id : "$by_user", last_url : {$last : "$url"}}}]) |

**管道的概念**

管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。

MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。

表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。

这里我们介绍一下聚合框架中常用的几个操作：

- $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。
- $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。
- $limit：用来限制MongoDB聚合管道返回的文档数。
- $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。
- $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。
- $group：将集合中的文档分组，可用于统计结果。
- $sort：将输入文档排序后输出。
- $geoNear：输出接近某一地理位置的有序文档。